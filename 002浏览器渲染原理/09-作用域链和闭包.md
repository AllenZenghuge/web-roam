# 作用域链和闭包 ：代码中出现相同的变量，JavaScript引擎是如何选择的？

作用域和作用域链式所有编程语言的基础

JS的作用域和作用域链的实现是通过execution context之中的variable environment-outer实现的

```js
function bar() {
    console.log(myName)
}
function foo() {
    var myName = " 极客邦 "
    bar()
}
var myName = " 极客时间 "
foo() // 极客时间
```

并不是所想的按照调用栈寻找变量



类似代码在c环境的尝试

![image-20200527145353047](http://picbed.sedationh.cn/image-20200527145353047.png)

可见语言差异 这也是我在学习JS常常会**理所当然**得犯错的根源

## 作用域链

其实在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为**outer**。

![image-20200527145948487](http://picbed.sedationh.cn/image-20200527145948487.png)



## 词法作用域

**词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。**

**即：词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系**。

整合一下上一节的块级作用域，现在我们对于变量的查找的完整路径可以得出

![image-20200527150619181](http://picbed.sedationh.cn/image-20200527150619181.png)



## 闭包 closure

![image-20200527151133980](http://picbed.sedationh.cn/image-20200527151133980.png)

**在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包**。

**是否空间共用**

```js
function foo() {
  let name = 'SedationH'
  return {
    getName() {
      console.log(name)
    },
    setName(newName) {
      name = newName
    }
  }
}
const nameFn = foo()
nameFn.getName() // SedationH
nameFn.setName('1')
nameFn.getName() // 1
const otherNameFn = foo()
otherNameFn.getName() // SedationH
```

closure通过outer搜寻，如果变量用函数中有引用，就通过闭包(Closure)保存在内存中

```js
function foo() {
  let name = 'SedationH'
  let age  = 11
  return function bar() {
    var name = '2'
    let address = 'earth'
    return {
      getInfo() {
        var name = 1
        console.log(name)
        console.log(age)
        console.log(address)
      }
    }

  }
}
const nameFn = foo()()
nameFn.getInfo()
```

![image-20200527154749972](http://picbed.sedationh.cn/image-20200527154749972.png)



## 闭包回收

通常，如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。

如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。