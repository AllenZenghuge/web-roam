# JS手写系列👋

先要知道是什么，怎么用，再去实现



## call apply

The `all()` method calls a function with a given `this` value and arguments provided individually.

> **Note:** While the syntax of this function is almost identical to that of `apply()`, the fundamental difference is that `call()` accepts an **argument list**, while `apply()` accepts a **single array of arguments**.

简单来说 call和apply都用来改变执行函数时候函数内部的this指向，区别在于参数

假设有 obj = {}  arr = [arg1,arg2]

使用call -> fn.call(obj,...arr)

使用apply -> fn.apply(obj,arr)



[参考](https://github.com/mqyqingfeng/Blog/issues/11)

实现逻辑

1. 将函数设为对象的属性
2. 执行函数
3. 删除函数



**`arguments`** is an `Array`-like object accessible inside [functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions) that contains the values of the arguments passed to that function.

> **Note:** “Array-like” means that `arguments` has a [`length`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/length) property and properties indexed from zero, but it doesn't have [`Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)'s built-in methods like [`forEach()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach) and [`map()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map). See [§Description](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments#Description) for details.

The `Array.from()` method creates a new, shallow-copied `Array` instance from an array-like or iterable object.



```js
Function.prototype.call = function (obj) {
  if (typeof this !== 'function') {
    throw new TypeError('Error')
  }
  obj = obj || window
  // 当前执行的函数为this 【参看this obj.fn() fn中的this就是obj】
  obj.fn = this
  // 去除掉obj参数，剩下的都是执行函数所需要的
  // res is The result of calling the function 
  // with the specified this value and arguments.
  let res = obj.fn(...Array.from(arguments).slice(1))
  delete obj.fn
  return res
}

Function.prototype.apply = function (obj) {
  if (typeof this !== 'function') {
    throw TypeError('Error')
  }
  obj = obj || window
  obj.fn = this
  let res
  if (obj) {
    res = obj.fn(...arguments[1])
  } else {
    res = obj.fn()
  }
  return res
}

```



## bind

## Syntax

```
let boundFunc = func.bind(thisArg[, arg1[, arg2[, ...argN]]])
```

### Parameters



- `thisArg`

  The value to be passed as the `this` parameter to the target function `func` when the bound function is called. The value is ignored if the bound function is constructed using the new operator. When using `bind` to create a function (supplied as a callback) inside a `setTimeout`, any primitive value passed as `thisArg` is converted to object. If no arguments are provided to `bind`, the `this` of the executing scope is treated as the `thisArg` for the new function.

- `arg1, arg2, ...argN` Optional

  Arguments to prepend to arguments provided to the bound function when invoking `func`.

### Return value



A copy of the given function with the specified `this` value, and initial arguments (if provided).



obj = {}

function fn(){}

bindFn = fn.bind(obj,a,b)

bindFn(c) 等价于 fn.call(obj,a,b,c)



```js
Function.prototype.bind = function (obj) {
  if (typeof this !== 'function') {
    throw new TypeError('Error')
  }
  const _this = this
  const args = [...arguments].slice(1)
  // 返回函数 不立刻执行
  return function F() {
    // 通过new Con() 调用的话 obj失效， this绑定到实例上
    // new Con().bind() new Con()代码执行，返回实例 instanceof 这个实例
    if (this instanceof F) {
      return new _this(...args, ...arguments)
    } else {
      return _this.apply(obj, args.concat(...arguments))
    }
  }
}
```

