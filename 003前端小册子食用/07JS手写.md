# JSæ‰‹å†™ç³»åˆ—ğŸ‘‹

å…ˆè¦çŸ¥é“æ˜¯ä»€ä¹ˆï¼Œæ€ä¹ˆç”¨ï¼Œå†å»å®ç°



## call apply

The `all()` method calls a function with a given `this` value and arguments provided individually.

> **Note:** While the syntax of this function is almost identical to that of `apply()`, the fundamental difference is that `call()` accepts an **argument list**, while `apply()` accepts a **single array of arguments**.

ç®€å•æ¥è¯´ callå’Œapplyéƒ½ç”¨æ¥æ”¹å˜æ‰§è¡Œå‡½æ•°æ—¶å€™å‡½æ•°å†…éƒ¨çš„thisæŒ‡å‘ï¼ŒåŒºåˆ«åœ¨äºå‚æ•°

å‡è®¾æœ‰ obj = {}  arr = [arg1,arg2]

ä½¿ç”¨call -> fn.call(obj,...arr)

ä½¿ç”¨apply -> fn.apply(obj,arr)



[å‚è€ƒ](https://github.com/mqyqingfeng/Blog/issues/11)

å®ç°é€»è¾‘

1. å°†å‡½æ•°è®¾ä¸ºå¯¹è±¡çš„å±æ€§
2. æ‰§è¡Œå‡½æ•°
3. åˆ é™¤å‡½æ•°



**`arguments`** is an `Array`-like object accessible inside [functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions) that contains the values of the arguments passed to that function.

> **Note:** â€œArray-likeâ€ means that `arguments` has a [`length`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/length) property and properties indexed from zero, but it doesn't have [`Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)'s built-in methods like [`forEach()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach) and [`map()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map). See [Â§Description](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments#Description) for details.

The `Array.from()` method creates a new, shallow-copied `Array` instance from an array-like or iterable object.



```js
Function.prototype.call = function (obj) {
  if (typeof this !== 'function') {
    throw new TypeError('Error')
  }
  obj = obj || window
  // å½“å‰æ‰§è¡Œçš„å‡½æ•°ä¸ºthis ã€å‚çœ‹this obj.fn() fnä¸­çš„thiså°±æ˜¯objã€‘
  obj.fn = this
  // å»é™¤æ‰objå‚æ•°ï¼Œå‰©ä¸‹çš„éƒ½æ˜¯æ‰§è¡Œå‡½æ•°æ‰€éœ€è¦çš„
  // res is The result of calling the function 
  // with the specified this value and arguments.
  let res = obj.fn(...Array.from(arguments).slice(1))
  delete obj.fn
  return res
}

Function.prototype.apply = function (obj) {
  if (typeof this !== 'function') {
    throw TypeError('Error')
  }
  obj = obj || window
  obj.fn = this
  let res
  if (obj) {
    res = obj.fn(...arguments[1])
  } else {
    res = obj.fn()
  }
  return res
}

```



## bind

## Syntax

```
let boundFunc = func.bind(thisArg[, arg1[, arg2[, ...argN]]])
```

### Parameters



- `thisArg`

  The value to be passed as the `this` parameter to the target function `func` when the bound function is called. The value is ignored if the bound function is constructed using the new operator. When using `bind` to create a function (supplied as a callback) inside a `setTimeout`, any primitive value passed as `thisArg` is converted to object. If no arguments are provided to `bind`, the `this` of the executing scope is treated as the `thisArg` for the new function.

- `arg1, arg2, ...argN` Optional

  Arguments to prepend to arguments provided to the bound function when invoking `func`.

### Return value



A copy of the given function with the specified `this` value, and initial arguments (if provided).



obj = {}

function fn(){}

bindFn = fn.bind(obj,a,b)

bindFn(c) ç­‰ä»·äº fn.call(obj,a,b,c)



```js
Function.prototype.bind = function (obj) {
  if (typeof this !== 'function') {
    throw new TypeError('Error')
  }
  const _this = this
  const args = [...arguments].slice(1)
  // è¿”å›å‡½æ•° ä¸ç«‹åˆ»æ‰§è¡Œ
  return function F() {
    // é€šè¿‡new Con() è°ƒç”¨çš„è¯ objå¤±æ•ˆï¼Œ thisç»‘å®šåˆ°å®ä¾‹ä¸Š
    // new Con().bind() new Con()ä»£ç æ‰§è¡Œï¼Œè¿”å›å®ä¾‹ instanceof è¿™ä¸ªå®ä¾‹
    if (this instanceof F) {
      return new _this(...args, ...arguments)
    } else {
      return _this.apply(obj, args.concat(...arguments))
    }
  }
}
```

