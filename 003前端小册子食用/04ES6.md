## execution context

刷过面试题的都知道这是因为 JavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个“准备工作”，比如第一个例子中的变量提升，和第二个例子中的函数提升。

但是本文真正想让大家思考的是：这个“一段一段”中的“段”究竟是怎么划分的呢？

到底JavaScript引擎遇到一段怎样的代码时才会做“准备工作”呢？

### 可执行代码

这就要说到 JavaScript 的可执行代码(executable code)的类型有哪些了？

其实很简单，就三种，全局代码、函数代码、eval代码。

举个例子，当执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，就叫做"执行上下文(execution context)"。

对于每个执行上下文，都有三个重要属性：

- 变量对象(Variable object，VO)
- 作用域链(Scope chain)
- this



## 函数上下文

在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。

活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。

活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。

### 执行过程

执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做：

1. 进入执行上下文
2. 代码执行

#### 进入执行上下文

当进入执行上下文时，这时候还没有执行代码，

变量对象会包括：

1. 函数的所有形参 (如果是函数上下文)
   - 由名称和对应值组成的一个变量对象的属性被创建
   - 没有实参，属性值设为 undefined
2. 函数声明
   - 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建
   - 如果变量对象已经存在相同名称的属性，则完全替换这个属性
3. 变量声明
   - 由名称和对应值（undefined）组成一个变量对象的属性被创建；
   - 如果变量名称跟已经声明的**形式参数或函数相同，则变量声明不会干扰已经存在的这类属性**

举个例子：

```js
function foo(a) {
  var b = 2;
  function c() {}
  var d = function() {};

  b = 3;

}

foo(1);
```

在进入执行上下文后，这时候的 AO 是：

```js
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: undefined,
    c: reference to function c(){},
    d: undefined
}
```

#### 代码执行

在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值

还是上面的例子，当代码执行完后，这时候的 AO 是：

```js
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: 3,
    c: reference to function c(){},
    d: reference to FunctionExpression "d"
}
```



## var let const

### **Hoisting**

在使用var 和 函数声明的时候都会发生**Hoisting**（变量提升）

Hoisting was thought up as a general way of thinking about how **execution contexts** (specifically the creation and execution phases) work in JavaScript. 



One of the advantages of JavaScript putting function declarations into memory before it executes any code segment is that it allows you to use a function before you declare it in your code. For example:

```js
catName("Chloe");

function catName(name) {
  console.log("My cat's name is " + name);
}
/*
The result of the code above is: "My cat's name is Chloe"
*/
```

JavaScript only hoists declarations, not initializations. If a variable is declared and initialized after using it, the value will be undefined. For example:

```js
console.log(num); // Returns undefined, as only declaration was hoisted, no initialization has happened at this stage 
var num; // declaration
num = 6; // initialization
```



### 关于函数创建

A function expression is very similar to and has almost the same syntax as a function declaration (see [`function statement`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function) for details). The main difference between a function expression and a function declaration is the *function name*, which can be omitted in function expressions to create *anonymous* functions. A function expression can be used as an [IIFE (Immediately Invoked Function Expression)](https://developer.mozilla.org/en-US/docs/Glossary/IIFE) which runs as soon as it is defined. 

### 关于优先级

```js
console.log(a);    // f a() {console.log(10)}
console.log(a());    //  10

var a = 3;
function a() {
  return 10
}
console.log(a)   //3
console.log(a())  //a is not a function;


//等价于
function a() {
  return 10
}
var a
console.log(a)
console.log(a())
a = 3
console.log(a) 
console.log(a());

```

由此可见函数提升要比变量提升的优先级要高一些，且不会被变量声明覆盖，但是会被变量赋值之后覆盖。

### 为什么要引入const let

解决全局作用域和函数作用域，没有块级作用域而带来的不合理的场景。

变量提升的一些奇怪问题。

主要特点

1. 具有块级作用域
2. Temporal dead zone，不能在声明前使用
3. `let` 和 `const` 作用基本一致，但是后者声明的变量不能再次赋值
4. `var` 在全局作用域下声明变量会导致变量挂载在 `window` 上，其他两者不会



## 原型继承和 Class 继承

先要理解new起到的作用，见03JS基础3



new 构造函数  -> 实例 实例自动绑定到构造函数的.prototype上，并且可以通过实例.proto进行访问



在使用过程中，构造函数主要用于绑定属性，原型上放函数(这样就不用共用的方法还要各自创建空间了)

### 原型继承之组合继承、寄生组合继承

**组合继承**

```js
function Parent(value) {
  this.val = value
}
Parent.prototype.getValue = function() {
  console.log(this.val)
}
function Child(value) {
  Parent.call(this, value)
}
Child.prototype = new Parent()

const child = new Child(1)

child.getValue() // 1
child instanceof Parent // true
```

在子类构造函数中调用父类的构造函数，再把子类构造函数的原型赋值为父类构造函数的实例对象在判断 child instance of Parent中，child.protp.proto === Parent.prototype

缺点是因为是用实例作为桥梁，继承父类的构造函数，导致子类原型上多了不需要的父类的属性，存在内存上的浪费

![image-20200508110156851](http://picbed.sedationh.cn/image-20200508110156851.png)

在理解的过程中可能会疑问

`child instanceof Child`为什么成立，注意我们修改了Child的prototype

`instanceof`的原理是

> 判断left.proto === right.prototype
>
> 如果false left = left.proto 通过 原型链遍历直到null

![image-20200508105318137](http://picbed.sedationh.cn/image-20200508105318137.png)

**寄生组合继承**

```js
function Parent(value) {
  this.val = value
}
Parent.prototype.getValue = function() {
  console.log(this.val)
}

function Child(value) {
  Parent.call(this, value)
}
Child.prototype = Object.create(Parent.prototype, {
  constructor: {
    value: Child,
    enumerable: false,
    writable: true,
    configurable: true
  }
})

const child = new Child(1)

child.getValue() // 1
child instanceof Parent // true
```

因为组合继承的缺点在于继承父类函数时候（重新赋值子类原型对象的时候）使用实例作为桥梁，调用了父类构造函数，产生了不需要的变量

So 我们就用父类构造函数的原型就好了

以上继承实现的核心就是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数。

![image-20200508110505108](http://picbed.sedationh.cn/image-20200508110505108.png)



### Class继承

class只是语法糖，只是对原型方案的封装,class的本质是函数

[参看](https://segmentfault.com/a/1190000008338987)

```js
class Parent {
  constructor(value) {
    this.val = value
  }
  getValue() {
    console.log(this.val)
  }
}
class Child extends Parent {
  constructor(value) {
    // super() 指的是调用父类
    // 调用的同时，会绑定 this 。
    // 相当于Parent.call(this, value)
    super(value)
    this.val = value
  }
}
let child = new Child(1)
child.getValue() // 1
child instanceof Parent // true
```



