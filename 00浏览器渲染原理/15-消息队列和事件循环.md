# 消息队列和事件循环：页面是怎么“活”起来的？

> **渲染进程**。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。

**渲染进程的线程：**

主要有IO线程，用开负责和其它进程IPC通信的，然后主线程主要跑页面的！

V8是在主线程上执行的，因为dom操作啥的都是在主线程上执行的。

当然还有其它很多辅助线程，比如预解析DOM的线程，垃圾回收也有一些辅助线程。



每个渲染进程都有一个主线程，并且主线程非常繁忙，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件。**要让这么多不同类型的任务在主线程中有条不紊地执行，这就需要一个系统来统筹调度这些任务**，这个统筹调度系统就是我们今天要讲的消息队列和事件循环系统。



## 从简单到复杂，设计这样的一个系统

### 循环+事件

```c++
//GetInput
// 等待用户从键盘输入一个数字，并返回该输入的数字
int GetInput(){
    int input_number = 0;
    cout<<" 请输入一个数:";
    cin>>input_number;
    return input_number;
}
 
// 主线程 (Main Thread)
void MainThread(){
     for(;;){
          int first_num = GetInput()；
          int second_num = GetInput()；
          result_num = first_num + second_num;
          print(" 最终计算的值为:%d",result_num)；
      }
}
```

现在已经能够循环处理主线程的事件，但是实际上渲染主线程会频繁收到来自IO线程的一些任务，比如接收到资源加载完成的消息后，渲染进程就要着手进行 DOM 解析了；接收到鼠标点击的消息后，渲染主线程就要开始执行相应的 JavaScript 脚本来处理该点击事件。

我们需要引入**消息队列**来解决

### 循环+事件+消息队列

> 所谓消息队列是一种数据结构，存放**要执行的任务**，具有**先进先出**的特点

![image-20200530114115398](http://picbed.sedationh.cn/image-20200530114115398.png)

```c++
class TaskQueue{
  public:
  	Task takeTask(); // 取出头部任务
  	void pushTask(Task task); //添加任务到尾部
}

TaskQueue task_queue；
void ProcessTask();
void MainThread(){
  while(true){
    Task task = task_queue.takeTask();
    ProcessTask(task);
  }
}

void IOThread(){
  Task clickTask;
	task_queue.pushTask(clickTask);
}
```

现在其他线程发送的任务渲染进程的主线程就可以通过消息队列来执行了



⚠️注意消息队列操作具体实现的时候要有同步锁

### Chrome中的具体实现

![image-20200530115055807](http://picbed.sedationh.cn/image-20200530115055807.png)

对于其他进程发来的任务，渲染进程通过IO集中处理 -> 消息对立



渲染进程中所有运行在主线程上的任务都需要先添加到消息队列，然后事件循环系统再按照顺序执行消息队列中的任务。下面我们来看看那些典型的事件：

- 当接收到 HTML 文档数据，渲染引擎就会将“解析 DOM”事件添加到消息队列中，
- 当用户改变了 Web 页面的窗口大小，渲染引擎就会将“重新布局”的事件添加到消息队列中。
- 当触发了 JavaScript 引擎垃圾回收机制，渲染引擎会将“垃圾回收”任务添加到消息队列中。
- 同样，如果要执行一段异步 JavaScript 代码，也是需要将执行任务添加到消息队列中。

以上列举的只是一小部分事件，这些事件被添加到消息队列之后，事件循环系统就会按照消息队列中的顺序来执行事件。



### 一些问题

页面线程所有执行的任务都来自于消息队列。消息队列是“先进先出”的属性，也就是说放入队列中的任务，需要等待前面的任务被执行完，才会被执行。鉴于这个属性，就有如下两个问题需要解决。



#### **第一个问题是如何处理高优先级的任务。**

> 比如一个典型的场景是监控 DOM 节点的变化情况（节点的插入、修改、删除等动态变化），然后根据这些变化来处理相应的业务逻辑。一个通用的设计的是，利用 JavaScript 设计一套监听接口，当变化发生时，渲染引擎同步调用这些接口，这是一个典型的观察者模式。
>
> 不过这个模式有个问题，因为 DOM 变化非常频繁，如果每次发生变化的时候，都直接调用相应的 JavaScript 接口，那么这个当前的任务执行时间会被拉长，从而导致**执行效率的下降**。
>
> 如果将这些 DOM 变化做成异步的消息事件，添加到消息队列的尾部，那么又会影响到监控的实时性，因为在添加到消息队列的过程中，可能前面就有很多任务在排队了。
>
> 这也就是说，如果 DOM 发生变化，采用同步通知的方式，会影响当前任务的**执行效率**；如果采用异步方式，又会影响到**监控的实时性**。

Solution: 引入**微任务**

通常我们把消息队列中的任务称为**宏任务**，每个宏任务中都包含了一个**微任务队列**，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。

等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题。



#### **第二个是如何解决单个任务执行时长过久的问题。**

> 因为所有的任务都是在单线程中执行的，所以每次只能执行一个任务，而其他任务就都处于等待状态。如果其中一个任务执行时间过久，那么下一个任务就要等待很长时间。可以参考下图：

Solution: **回调机制**