# 异步编码的演进

我们利用JS消息队列(微任务、宏任务)、回调函数等机制来实现异步



但仅仅使用回调函数进行异步编码，会产生大量的嵌套回调和重复的异常判断，为此，JS的异步编码一直在进步



回调函数-> Promise -> Generator -> async/await

[前两个过程参考](https://github.com/SedationH/promise-study)不再赘述



## Generator函数

**生成器函数是一个带星号函数，而且是可以暂停执行和恢复执行的**。

```js
function* genDemo(){
	console.log('开始执行')
  yield 1
  console.log('yield 后面的代码执行再被返回，被包装')
  yield 1+1
  console.log('return 也是')
  return 3
}
let iterator = genDemo() // 执行generator函数会返回一个迭代器(此时函数还没有执行)
iterator.next()
// 开始执行
// {value: 1, done: false}
iterator.next()
// yield 后面的代码执行再被返回，被包装
// 2
iterator.next()
// return 也是
// {value: 3, done: true}
```

**生成器(Generator)函数的底层机制——协程(Coroutine)**

> **协程是一种比线程更加轻量级的存在**。你可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程，比如当前执行的是 A 协程，要启动 B 协程，那么 A 协程就需要将主线程的控制权交给 B 协程，这就体现在 A 协程暂停执行，B 协程恢复执行；同样，也可以从 B 协程中启动 A 协程。通常，**如果从 A 协程启动 B 协程，我们就把 A 协程称为 B 协程的父协程**。
>
> 正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。

![image-20200602171541458](http://picbed.sedationh.cn/image-20200602171541458.png)

generator与promise进行配合

```js
//foo 函数
function* foo() {
    let response1 = yield fetch('https://www.geekbang.org')
    console.log('response1')
    console.log(response1)
    let response2 = yield fetch('https://www.geekbang.org/test')
    console.log('response2')
    console.log(response2)
}
 
// 执行 foo 函数的代码
let gen = foo()
function getGenPromise(gen) {
    return gen.next().value
}
getGenPromise(gen).then((response) => {
    console.log('response1')
    console.log(response)
    return getGenPromise(gen)
}).then((response) => {
    console.log('response2')
    console.log(response)
})

/*-----------------------------*/

function* foo() {
    let response1 = yield fetch('https://www.geekbang.org')
    console.log('response1')
    console.log(response1)
    let response2 = yield fetch('https://www.geekbang.org/test')
    console.log('response2')
    console.log(response2)
}

/*
通常，我们把执行生成器的代码封装成一个函数，并把这个执行生成器代码的函数称为执行器（可参考著名的 co 框架），如下面这种方式：
*/
co(foo())
```

这样异步代码的可读性就大大提高了



## async/await

这个方案其实是个语法糖，从语言上帮我们封装generate+promise

async 是一个通过异步执行并隐式返回Promise作为结果的函数

```js
async function foo(){
	console.log(1)
  return 1
}
foo() // Promise {<resolved>: 1}
console.log(2)
// 1？
// 2
```

await是配合async实现异步的关键字

```js
async function foo() {
    console.log(1)
    let a = await 100
    console.log(a)
    console.log(2)
}
console.log(0)
foo()
console.log(3)
// 0 1 3 100 2
```

**过程图解**

![image-20200602172646472](http://picbed.sedationh.cn/image-20200602172646472.png)

当执行到`await 100`时，会默认创建一个 Promise 对象

```js
let promise_ = new Promise((resolve,reject){
  resolve(100)
})
```

然后 JavaScript 引擎会暂停当前协程的执行，将主线程的控制权转交给父协程执行，同时会将 promise_ 对象返回给父协程。

主线程的控制权已经交给父协程了，这时候父协程要做的一件事是调用 promise_.then 来监控 promise 状态的改变。

接下来继续执行父协程的流程，这里我们执行`console.log(3)`，并打印出来 3。随后父协程将执行结束，在结束之前，会进入微任务的检查点，然后执行微任务队列，微任务队列中有`resolve(100)`的任务等待执行，执行到这里的时候，会触发 promise_.then 中的回调函数，如下所示：

```js
promise_.then((value)=>{
   // 回调函数被激活后
  // 将主线程控制权交给 foo 协程，并将 vaule 值传给协程
})
```

该回调函数被激活以后，会将主线程的控制权交给 foo 函数的协程，并同时将 value 值传给该协程。

foo 协程激活之后，会把刚才的 value 值赋给了变量 a，然后 foo 协程继续执行后续语句，执行完成之后，将控制权归还给父协程。



思考题

```js
async function foo() {
    console.log('foo')
}
async function bar() {
    console.log('bar start')
    await foo()
    console.log('bar end')
}
console.log('script start')
setTimeout(function () {
    console.log('setTimeout')
}, 0)
bar();
new Promise(function (resolve) {
    console.log('promise executor')
    resolve();
}).then(function () {
    console.log('promise then')
})
console.log('script end')
```



主线程 ->  微任务 -> 宏任务

